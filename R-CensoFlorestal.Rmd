```{r}
# Executa a amostragem casual simples para inventário florestal na região de nova lima mg
#Entrada: Parcela, árvore, fuste, espécie, CAP, altura
#Saida: fitossociologia, volumetria, parametros da amostragem, distribuição de altura e diamétrica 
```

```{r}
#bibliotecas e importações

library(openxlsx)
library(ggplot2)
library(dplyr)
options(OutDec = ".")

```

```{r}
#funções utilizadas

#importação de dados
ImportarDados <- function(){
 
  return(openxlsx::read.xlsx(file.choose()))
}

#Acrescenta Colunas de Dados: dap, AB, Vol
calcDAV <- function(DadosTemp){
  
  DadosTemp$DAP <- (DadosTemp$CAP / pi)
  DadosTemp$AB <- (pi/40000) * (DadosTemp$DAP ^ 2)
  DadosTemp$VTcc <- exp(-9.77830707 + 2.1472609409 * log(DadosTemp$DAP, exp(1)) + 0.7804098114 * log(DadosTemp$Altura, exp(1)))
  DadosTemp <- DadosTemp[, c(1, 2, 3, 4, 5, 7, 6, 8, 9)] #modificar ordem das colunas
  
  return(DadosTemp)
}

#calcula a tabela de volume por parcela
calcVolumeTab <- function(DadosTemp){
  
  DadosVol <- aggregate(DadosTemp$VTcc, by=list(DadosTemp$Parcela), FUN=sum)
  colnames(DadosVol)[c(1,2)]<- c("Parcela","VTcc", "VolST")
  DadosVol$VolST <- DadosVol$VTcc * 1.5
  
  return(DadosVol)
}

#Recebe os parametros do inventário. Padrão: AreaParc=300, AreaTotal=2, erro=10, confi=90
receberParametros <- function(){
    
    #readline()
    #AreaTotal <- as.numeric(readline("Digite a área total em hectares: ")) 
    #AreaParc <- as.numeric(readline("Digite a área da parcela em m²: "))
    #ErroMax <- as.numeric(readline("Digite o erro máximo admissível: "))
    #Probabilidade <- as.numeric(readline("Digite o nível de probabilidade: ")) 
  
    return(data.frame(AreaTotal = 2, AreaParc = 300, ErroMax = 10, Probabilidade = 90)) 
      
}

#calcula o inverso de T bicaudal - equivalente ao INV.T.BC no excel
inv.t.bc <- function(p, gl) {
  invt <- qt(1-(((100-p)/100)/2),gl)
 
   return(invt)
}

#calcula os parametros do inventário
calcParamInventario <- function(DadosVol, Parametros){
    fatorEstereo <- 1.5
    ParamACS <- data.frame(
    Parâmetro = c("Área total", "Vol. Total Mensurado", "N. Parc. Possíveis", 
                   "Área da parcela", "N. Parc. Lançadas (n)", "Média", 
                   "Variância", "Desvio-padrão", "Valor de t",
                   "Erro Máximo Admissível", "Coeficiente de Variação", "Erro-padrão da média","Erro de amostragem",
                   "N. Parcelas Necessárias", "Vol. Mínimo", "Vol. Médio", "Vol. Máximo", "St. Mínimo", "St. Médio", "St. Máximo"  ),
   Valor = 0,
   
   Unidade = c("ha", "m³", "un", 
               "m²", "un","m³",
               "m³²", "m³", paste(as.character(Parametros$Probabilidade), "%"),
               "%", "%", "%", "%",
               "un","m³/ha", "m³/ha", "m³/ha",
               "st/ha", "st/ha", "st/ha")
   
   )
  
    #calcular cada parâmetro separadamente antes de passar para o dataframe
    #Variáveis Temporarias com a letra t neste contexto
      tMedia <- mean(DadosVol$VTcc)
      tDesvioPadrao <- sd(DadosVol$VTcc)
      tVariancia <- tDesvioPadrao ^ 2
      tCoefVariacao <- tDesvioPadrao / tMedia
      tValorT <- inv.t.bc(Parametros$Probabilidade, nrow(DadosVol)-1)
      tNumMaxParcelas <- as.integer(ceiling((Parametros$AreaTotal * 10000) / Parametros$AreaParc))
     
       #valor de erro padrao da media (amostra finita ou infinita)
      if (nrow(DadosVol)/tNumMaxParcelas > 0.02) {
        tErroPadMedia <- sqrt((tVariancia / nrow(DadosVol)) * (1 - (nrow(DadosVol) / tNumMaxParcelas)))
      } else {
        tErroPadMedia <- sqrt(tVariancia/nrow(DadosVol))
      }
      tErroPadMedia <- tErroPadMedia
      
      tErroAmostragem <- (tErroPadMedia * tValorT) / tMedia
      
      #valor de n (amostra finita ou infinita)
      if (nrow(DadosVol)/tNumMaxParcelas > 0) {
        tValorNn <- ((tValorT ^ 2) * (tCoefVariacao ^ 2)) / (((Parametros$ErroMax/100)^2) + (((tValorT ^ 2) * (tCoefVariacao ^ 2))/tNumMaxParcelas))
        
      } else {
        tValorNn <- ((tValorT ^ 2) * (tCoefVariacao ^ 2)) / (((Parametros$ErroMax/100)^2))
      }
      
      tValorNn <- as.integer(ceiling(tValorNn))
      tVolMed <- sum(DadosVol$VTcc) / (nrow(DadosVol)*(Parametros$AreaParc/10000))
      tVolMin <- tVolMed - tVolMed * tErroAmostragem
      tVolMax <- tVolMed + tVolMed * tErroAmostragem
      
      ParamACS$Valor <- c(Parametros$AreaTotal, sum(DadosVol$VTcc), tNumMaxParcelas,
                          Parametros$AreaParc, nrow(DadosVol), round(tMedia,5),
                          tVariancia, tDesvioPadrao, tValorT,
                          Parametros$ErroMax, tCoefVariacao * 100, tErroPadMedia * 100, tErroAmostragem * 100,
                          tValorNn, tVolMin, tVolMed, tVolMax, tVolMin * fatorEstereo, tVolMed * fatorEstereo, tVolMax * fatorEstereo)

    return(ParamACS)
} 

#retorna a distribuição diamétrica
calcDistDiametrica <- function(DadosDiam){
  
  #monta a tabela de classes diametricas
  numClasses <- ceiling(max(DadosDiam$DAP)/5) - 1 #define a maior classe
  numDiametros <- data.frame() 
  
  contWhile <- 1
  while (contWhile <= numClasses){
  
    numDiametros <- rbind(numDiametros, (paste(contWhile * 5, "-",(1 + contWhile) * 5, sep = "")))
    contWhile <- contWhile + 1
  
  }
  
  #cria a tabela de classes
  colnames(numDiametros)[1] <- "Classe" #muda o nome da coluna
  DiamHisto <- hist(DadosDiam$DAP, breaks=seq(5,(1+numClasses)*5,5), plot=FALSE) #faz o histograma a cada 5 cm até o máximo
  numDiametros$Num <- cbind(DiamHisto[["counts"]])
  numDiametros$Num <- numDiametros$Num
  colnames(numDiametros)[2] <- "Num.Fuste" #muda o nome da coluna
  numDiametros <- data.frame(rbind(numDiametros, c("Total", sum(numDiametros$Num)))) #soma o total
  numDiametros$Num.Fuste <- sapply(numDiametros$Num.Fuste, as.numeric)
 
  return(numDiametros)

}

#retorna a distribuição de alturas
calcDistAltura <- function(DadosAltura){

#monta a tabela de classes de altura
  numAlturas <- data.frame("Classe" = c(paste(as.character(round(min(DadosAltura$Altura)),1)," - ",as.character(round(mean(DadosAltura$Altura, na.rm=TRUE)-sd(DadosAltura$Altura, na.rm=TRUE), 1)),
                      sep=""),paste(as.character(round(mean(DadosAltura$Altura, na.rm=TRUE) - sd(DadosAltura$Altura, na.rm=TRUE), 1)), " - ", as.character(round(mean(DadosAltura$Altura, na.rm=TRUE) +                           sd(DadosAltura$Altura, na.rm=TRUE), 1)), sep="" ), paste( as.character(round(mean(DadosAltura$Altura, na.rm=TRUE) + sd(DadosAltura$Altura, na.rm=TRUE), 1))," - ",                                          as.character(round(max(DadosAltura$Altura, na.rm=TRUE),1)), sep="")))

  tempAlturas <- data.frame(Altura=DadosAltura$Altura, cls=0)
  tempAlturaMedia <- mean(tempAlturas$Altura, na.rm=TRUE)
  tempAlturaDesvPad <- sd(tempAlturas$Altura, na.rm = TRUE)

  tempAlturas$cls <- ifelse(tempAlturas$Altura < tempAlturaMedia - tempAlturaDesvPad, 1 , ifelse(tempAlturas$Altura >= tempAlturaMedia + tempAlturaDesvPad, 3, 2))

  tempContador <- count(tempAlturas, tempClasseNumero=cls==1)
  numAlturas[1,2] <- max(ifelse(tempContador$tempClasseNumero==TRUE, tempContador$n, 0))

  tempContador <- count(tempAlturas, tempClasseNumero=cls==2)
  numAlturas[2,2] <- max(ifelse(tempContador$tempClasseNumero==TRUE, tempContador$n, 0))

  tempContador <- count(tempAlturas, tempClasseNumero=cls==3)
  numAlturas[3,2] <- max(ifelse(tempContador$tempClasseNumero==TRUE, tempContador$n, 0))

  colnames(numAlturas)[2] <- "Num.Fustes"
  
  return(numAlturas)

}

 #monta a tabela de classes de altura
calcTabelaClasseAltura <- function(DadosAltura){
  
  
  tempAlturas <- data.frame(Altura=DadosAltura$Altura, cls=0)
  tempMediaAltura <- mean(tempAlturas$Altura, na.rm=TRUE)
  tempDesvPadAltura <- sd(tempAlturas$Altura, na.rm = TRUE)

  tempAlturas$cls <- ifelse(tempAlturas$Altura < tempMediaAltura - tempDesvPadAltura, 1, ifelse(tempAlturas$Altura >= tempMediaAltura+tempDesvPadAltura, 3, 2))

  colnames(tempAlturas)[2] <- "Classe"

  return(tempAlturas)
  
}

#plota o grafico de estratificação vertical
plotarEstratVertical <- function(DadosAltura){
  grafico <- (ggplot(DadosAltura, aes(c(x=1:nrow(DadosAltura)),y=DadosAltura[,1], fill=as.factor(DadosAltura[,2]) ),) + 
    geom_col() + 
    scale_fill_manual(values=c("#779966","#88AA88", "#557755"), labels=c("Estrato inferior", "Estrato médio", "Estrato superior")) + 
    geom_line(y=mean(DadosAltura[,1])-sd(DadosAltura[,1]), color="#885555") +
    geom_line(y=mean(DadosAltura[,1])+sd(DadosAltura[,1]), color="#557755") + 
 
    labs(title="Perfil Vertical da Floresta", x="Indivíduo", y="Altura", fill="Legenda") + 
    theme(legend.position="bottom", panel.background = element_rect(fill="#DDEEDD", colour = "#CCCCDD"), plot.title = element_text(hjust=0.5)))
    
   return(grafico)
}


```

```{r}

#Corpo principal

#importação dos dados

#remove(DadosImportados)
#DadosImportados <- ImportarDados()
#DadosImportados <- calcDAV(DadosImportados)
#DadosVol <- calcVolumeTab(DadosImportados)

Parametros <- receberParametros()
Volumetria <- calcParamInventario(DadosVol, Parametros)
DistDiametrica <- calcDistDiametrica(DadosImportados)
DistAltura <- calcDistAltura(DadosImportados)
ClassesAltura <- plotarEstratVertical(calcTabelaClasseAltura(DadosImportados))

```

